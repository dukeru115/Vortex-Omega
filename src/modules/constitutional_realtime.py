"""
Constitutional Module Real-time Monitoring
=========================================

Enhanced constitutional oversight system implementing Algorithm 1 from NFCS v2.4.3
with real-time Hallucination Number (Ha) monitoring and automatic safety protocols.

This module provides:
1. Real-time Ha monitoring and threshold management
2. Early warning system for critical states
3. Automatic safety protocols and recovery mechanisms
4. Live integrity scoring and constitutional oversight
5. Integration with emergency desynchronization protocols

Based on NFCS Algorithm 1:
Input: system_state (containing Ha, integrity_score)
Output: Control signals ui(t) for all modules with real-time monitoring

Author: Team Omega (GenSpark AI Implementation)
License: CC BY-NC 4.0
Date: 2025-09-14
"""

import asyncio
import logging
import time
import threading
import json
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Callable, Tuple, Union
import numpy as np
from concurrent.futures import ThreadPoolExecutor
import websockets
import sqlite3
from pathlib import Path

logger = logging.getLogger(__name__)


class ConstitutionalStatus(Enum):
    """Enhanced constitutional system status"""
    NORMAL = "NORMAL"              # Normal operation
    MONITORING = "MONITORING"      # Enhanced monitoring active
    WARNING = "WARNING"           # Warning threshold exceeded
    CRITICAL = "CRITICAL"         # Critical threshold exceeded
    EMERGENCY = "EMERGENCY"       # Emergency protocols active
    RECOVERY = "RECOVERY"         # Recovery mode active
    FAILURE = "FAILURE"          # System failure detected


class ThreatLevel(Enum):
    """Threat assessment levels"""
    MINIMAL = 1    # Ha < 0.5
    LOW = 2        # Ha 0.5-1.0
    MODERATE = 3   # Ha 1.0-2.0
    HIGH = 4       # Ha 2.0-4.0
    CRITICAL = 5   # Ha 4.0-7.0
    EXTREME = 6    # Ha > 7.0


@dataclass
class RealTimeMetrics:
    """Real-time system metrics for constitutional monitoring"""
    timestamp: float = field(default_factory=time.time)
    
    # Core NFCS metrics
    hallucination_number: float = 0.0
    coherence_measure: float = 0.0
    defect_density: float = 0.0
    field_energy: float = 0.0
    
    # Integrity metrics
    integrity_score: float = 1.0
    constitutional_compliance: float = 1.0
    system_stability: float = 1.0
    
    # Performance metrics
    processing_latency_ms: float = 0.0
    memory_usage_mb: float = 0.0
    cpu_usage_percent: float = 0.0
    
    # Threat assessment
    threat_level: ThreatLevel = ThreatLevel.MINIMAL
    risk_factors: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            'timestamp': self.timestamp,
            'hallucination_number': self.hallucination_number,
            'coherence_measure': self.coherence_measure,
            'defect_density': self.defect_density,
            'field_energy': self.field_energy,
            'integrity_score': self.integrity_score,
            'constitutional_compliance': self.constitutional_compliance,
            'system_stability': self.system_stability,
            'processing_latency_ms': self.processing_latency_ms,
            'memory_usage_mb': self.memory_usage_mb,
            'cpu_usage_percent': self.cpu_usage_percent,
            'threat_level': self.threat_level.name,
            'risk_factors': self.risk_factors
        }


@dataclass
class ConstitutionalAlert:
    """Alert generated by constitutional monitoring system"""
    alert_id: str
    timestamp: float = field(default_factory=time.time)
    severity: ThreatLevel = ThreatLevel.LOW
    title: str = ""
    description: str = ""
    affected_modules: List[str] = field(default_factory=list)
    recommended_actions: List[str] = field(default_factory=list)
    metrics_snapshot: Optional[RealTimeMetrics] = None
    auto_resolved: bool = False
    resolution_time: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'alert_id': self.alert_id,
            'timestamp': self.timestamp,
            'severity': self.severity.name,
            'title': self.title,
            'description': self.description,
            'affected_modules': self.affected_modules,
            'recommended_actions': self.recommended_actions,
            'auto_resolved': self.auto_resolved,
            'resolution_time': self.resolution_time,
            'metrics': self.metrics_snapshot.to_dict() if self.metrics_snapshot else None
        }


@dataclass
class ConstitutionalConfiguration:
    """Configuration for constitutional monitoring system"""
    
    # Hallucination Number thresholds
    ha_warning_threshold: float = 1.0
    ha_critical_threshold: float = 2.0
    ha_emergency_threshold: float = 4.0
    ha_failure_threshold: float = 7.0
    
    # Integrity thresholds  
    integrity_warning_threshold: float = 0.7
    integrity_critical_threshold: float = 0.5
    integrity_failure_threshold: float = 0.3
    
    # Monitoring intervals
    monitoring_interval_ms: int = 100      # 10 Hz monitoring
    alert_evaluation_interval_ms: int = 500  # 2 Hz alert evaluation
    metrics_retention_hours: int = 24      # Metrics retention
    
    # Emergency protocol settings
    emergency_desync_amplitude: float = -1.0
    emergency_timeout_seconds: float = 30.0
    recovery_assessment_interval: float = 5.0
    
    # Performance thresholds
    max_processing_latency_ms: float = 1000.0
    max_memory_usage_mb: float = 2048.0
    max_cpu_usage_percent: float = 90.0
    
    # Real-time dashboard
    enable_websocket_dashboard: bool = True
    dashboard_port: int = 8765
    max_websocket_connections: int = 10
    
    # Logging and persistence
    enable_metrics_persistence: bool = True
    database_path: str = "constitutional_monitoring.db"
    log_level: str = "INFO"


class ConstitutionalRealTimeMonitor:
    """
    Real-time constitutional monitoring system implementing Algorithm 1
    with enhanced safety protocols and live dashboard
    """
    
    def __init__(self, config: Optional[ConstitutionalConfiguration] = None):
        """Initialize constitutional monitoring system"""
        self.config = config or ConstitutionalConfiguration()
        
        # System state
        self.current_status = ConstitutionalStatus.NORMAL
        self.current_metrics = RealTimeMetrics()
        self.active_alerts: Dict[str, ConstitutionalAlert] = {}
        self.metrics_history: List[RealTimeMetrics] = []
        
        # Emergency state
        self.emergency_active = False
        self.emergency_start_time: Optional[float] = None
        self.recovery_mode_active = False
        
        # Threading and async
        self.monitoring_active = False
        self.executor = ThreadPoolExecutor(max_workers=4)
        self._monitoring_task: Optional[asyncio.Task] = None
        self._alert_task: Optional[asyncio.Task] = None
        
        # WebSocket dashboard
        self.websocket_server = None
        self.websocket_clients = set()
        
        # Database for persistence
        self.db_path = Path(self.config.database_path)
        self._init_database()
        
        # Callback functions for system integration
        self.module_control_callback: Optional[Callable] = None
        self.emergency_callback: Optional[Callable] = None
        self.metrics_callback: Optional[Callable] = None
        
        logger.info("Constitutional Real-time Monitor initialized")
    
    def _init_database(self):
        """Initialize SQLite database for metrics persistence"""
        if not self.config.enable_metrics_persistence:
            return
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS metrics (
                        timestamp REAL PRIMARY KEY,
                        hallucination_number REAL,
                        coherence_measure REAL,
                        defect_density REAL,
                        field_energy REAL,
                        integrity_score REAL,
                        threat_level TEXT,
                        data_json TEXT
                    )
                """)
                
                conn.execute("""
                    CREATE TABLE IF NOT EXISTS alerts (
                        alert_id TEXT PRIMARY KEY,
                        timestamp REAL,
                        severity TEXT,
                        title TEXT,
                        description TEXT,
                        auto_resolved BOOLEAN,
                        resolution_time REAL,
                        data_json TEXT
                    )
                """)
                
                # Create indexes for performance
                conn.execute("CREATE INDEX IF NOT EXISTS idx_metrics_timestamp ON metrics(timestamp)")
                conn.execute("CREATE INDEX IF NOT EXISTS idx_alerts_timestamp ON alerts(timestamp)")
                
            logger.info(f"Database initialized: {self.db_path}")
            
        except Exception as e:
            logger.error(f"Database initialization error: {e}")
    
    async def start_monitoring(self, 
                             module_control_callback: Optional[Callable] = None,
                             emergency_callback: Optional[Callable] = None,
                             metrics_callback: Optional[Callable] = None):
        """
        Start real-time constitutional monitoring
        
        Args:
            module_control_callback: Function to control NFCS modules
            emergency_callback: Function to activate emergency protocols
            metrics_callback: Function to collect system metrics
        """
        if self.monitoring_active:
            logger.warning("Monitoring already active")
            return
        
        # Set callback functions
        self.module_control_callback = module_control_callback
        self.emergency_callback = emergency_callback
        self.metrics_callback = metrics_callback
        
        self.monitoring_active = True
        
        # Start monitoring tasks
        self._monitoring_task = asyncio.create_task(self._monitoring_loop())
        self._alert_task = asyncio.create_task(self._alert_evaluation_loop())
        
        # Start WebSocket dashboard if enabled
        if self.config.enable_websocket_dashboard:
            await self._start_websocket_server()
        
        logger.info("Constitutional monitoring started")
    
    async def stop_monitoring(self):
        """Stop constitutional monitoring"""
        self.monitoring_active = False
        
        # Cancel tasks
        if self._monitoring_task:
            self._monitoring_task.cancel()
        if self._alert_task:
            self._alert_task.cancel()
        
        # Stop WebSocket server
        if self.websocket_server:
            self.websocket_server.close()
            await self.websocket_server.wait_closed()
        
        self.executor.shutdown(wait=True)
        
        logger.info("Constitutional monitoring stopped")
    
    async def _monitoring_loop(self):
        """Main monitoring loop - Algorithm 1 implementation"""
        while self.monitoring_active:
            try:
                start_time = time.time()
                
                # Step 1: Collect current system metrics
                await self._collect_system_metrics()
                
                # Step 2: Apply Algorithm 1 constitutional check
                decision = await self._apply_constitutional_algorithm()
                
                # Step 3: Execute control actions based on decision
                await self._execute_constitutional_decision(decision)
                
                # Step 4: Update system status
                self._update_system_status()
                
                # Step 5: Store metrics if persistence enabled
                if self.config.enable_metrics_persistence:
                    await self._store_metrics()
                
                # Step 6: Broadcast metrics to dashboard
                await self._broadcast_metrics()
                
                # Calculate processing time
                processing_time = (time.time() - start_time) * 1000
                self.current_metrics.processing_latency_ms = processing_time
                
                # Sleep until next monitoring cycle
                sleep_time = max(0, self.config.monitoring_interval_ms / 1000.0 - (time.time() - start_time))
                await asyncio.sleep(sleep_time)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Monitoring loop error: {e}")
                await asyncio.sleep(1.0)  # Error recovery delay
    
    async def _collect_system_metrics(self):
        """Collect real-time system metrics"""
        try:
            # Get metrics from callback if available
            if self.metrics_callback:
                metrics_data = await self._safe_callback(self.metrics_callback)
                
                if metrics_data:
                    # Update core metrics
                    self.current_metrics.hallucination_number = metrics_data.get('hallucination_number', 0.0)
                    self.current_metrics.coherence_measure = metrics_data.get('coherence_measure', 0.0)
                    self.current_metrics.defect_density = metrics_data.get('defect_density', 0.0)
                    self.current_metrics.field_energy = metrics_data.get('field_energy', 0.0)
                    self.current_metrics.integrity_score = metrics_data.get('integrity_score', 1.0)
            
            # Calculate derived metrics
            self._calculate_derived_metrics()
            
            # Update timestamp
            self.current_metrics.timestamp = time.time()
            
            # Add to history (with rotation)
            self.metrics_history.append(self.current_metrics)
            
            # Rotate history to maintain size
            max_history = int(self.config.metrics_retention_hours * 3600 * 1000 / self.config.monitoring_interval_ms)
            if len(self.metrics_history) > max_history:
                self.metrics_history = self.metrics_history[-max_history:]
                
        except Exception as e:
            logger.error(f"Metrics collection error: {e}")
    
    async def _apply_constitutional_algorithm(self) -> Dict[str, Any]:
        """
        Apply Algorithm 1 from NFCS paper with real-time enhancements
        
        Input: system_state (containing Ha, integrity_score)
        Output: Control signals ui(t) for all modules
        """
        ha_value = self.current_metrics.hallucination_number
        integrity_score = self.current_metrics.integrity_score
        
        decision = {
            'type': 'ACCEPT',
            'control_signals': {},
            'reasoning': [],
            'emergency_action': False
        }
        
        # Algorithm 1: Constitutional Check with conditions
        
        # 1. Check Ha threshold (Emergency condition)
        if ha_value > self.config.ha_emergency_threshold:
            logger.warning(f"EMERGENCY: Ha exceeded threshold: {ha_value}")
            
            # Emergency desynchronization for all modules  
            emergency_signal = self.config.emergency_desync_amplitude
            decision['control_signals'] = {
                'memory': emergency_signal * np.sin(np.linspace(0, 2*np.pi, 10)),
                'esc': emergency_signal * np.sin(np.linspace(0, 2*np.pi, 10)),
                'boundary': emergency_signal * np.sin(np.linspace(0, 2*np.pi, 10)),
                'symbolic': emergency_signal * np.sin(np.linspace(0, 2*np.pi, 10)),
                'kuramoto_all': emergency_signal
            }
            decision['type'] = 'EMERGENCY'
            decision['emergency_action'] = True
            decision['reasoning'].append(f"Ha={ha_value:.3f} > emergency_threshold={self.config.ha_emergency_threshold}")
            
        # 2. Check integrity threshold (Forced synchronization)
        elif integrity_score < self.config.integrity_critical_threshold:
            logger.warning(f"Integrity low: {integrity_score}, forcing synchronization")
            
            # Forced synchronization of core modules
            sync_signal = 1.0  # Strong synchronization signal
            target_modules = ['memory', 'esc', 'boundary']
            
            decision['control_signals'] = {}
            for module in target_modules:
                decision['control_signals'][module] = sync_signal * np.cos(np.linspace(0, 2*np.pi, 10))
            
            decision['type'] = 'FORCED_SYNC'
            decision['reasoning'].append(f"integrity={integrity_score:.3f} < threshold={self.config.integrity_critical_threshold}")
            
        # 3. Warning states (Enhanced monitoring)
        elif (ha_value > self.config.ha_warning_threshold or 
              integrity_score < self.config.integrity_warning_threshold):
            
            decision['type'] = 'MONITOR'
            decision['control_signals'] = {}  # No control intervention
            decision['reasoning'].append(f"Warning state: Ha={ha_value:.3f}, integrity={integrity_score:.3f}")
            
        # 4. Normal mode (Self-organization)
        else:
            decision['type'] = 'ACCEPT'
            decision['control_signals'] = {}  # Modules self-organize
            decision['reasoning'].append("Normal operation: modules self-organizing")
        
        return decision
    
    async def _execute_constitutional_decision(self, decision: Dict[str, Any]):
        """Execute constitutional decision with control signals"""
        try:
            decision_type = decision['type']
            control_signals = decision['control_signals']
            
            # Apply control signals through callback
            if self.module_control_callback and control_signals:
                await self._safe_callback(self.module_control_callback, control_signals)
            
            # Handle emergency actions
            if decision.get('emergency_action') and self.emergency_callback:
                if not self.emergency_active:
                    self.emergency_active = True
                    self.emergency_start_time = time.time()
                    await self._safe_callback(self.emergency_callback, {'activate': True})
                    logger.critical("Emergency protocols activated")
            
            # Handle recovery from emergency
            elif self.emergency_active and decision_type in ['ACCEPT', 'MONITOR']:
                # Check if emergency timeout reached or system stabilized
                emergency_duration = time.time() - (self.emergency_start_time or 0)
                
                if (emergency_duration > self.config.emergency_timeout_seconds or 
                    self.current_metrics.hallucination_number < self.config.ha_warning_threshold):
                    
                    self.emergency_active = False
                    self.emergency_start_time = None
                    self.recovery_mode_active = True
                    
                    if self.emergency_callback:
                        await self._safe_callback(self.emergency_callback, {'activate': False})
                    
                    logger.info("Emergency protocols deactivated, entering recovery mode")
            
            # Log decision
            reasoning = "; ".join(decision.get('reasoning', []))
            logger.debug(f"Constitutional decision: {decision_type} - {reasoning}")
            
        except Exception as e:
            logger.error(f"Decision execution error: {e}")
    
    def _calculate_derived_metrics(self):
        """Calculate derived metrics from core values"""
        ha = self.current_metrics.hallucination_number
        integrity = self.current_metrics.integrity_score
        coherence = self.current_metrics.coherence_measure
        
        # Calculate threat level
        if ha >= 7.0:
            self.current_metrics.threat_level = ThreatLevel.EXTREME
        elif ha >= 4.0:
            self.current_metrics.threat_level = ThreatLevel.CRITICAL
        elif ha >= 2.0:
            self.current_metrics.threat_level = ThreatLevel.HIGH
        elif ha >= 1.0:
            self.current_metrics.threat_level = ThreatLevel.MODERATE
        elif ha >= 0.5:
            self.current_metrics.threat_level = ThreatLevel.LOW
        else:
            self.current_metrics.threat_level = ThreatLevel.MINIMAL
        
        # Calculate constitutional compliance
        compliance_factors = []
        
        if ha <= self.config.ha_warning_threshold:
            compliance_factors.append(1.0)
        else:
            compliance_factors.append(max(0, 1.0 - (ha - self.config.ha_warning_threshold) / 2.0))
        
        if integrity >= self.config.integrity_warning_threshold:
            compliance_factors.append(1.0)
        else:
            compliance_factors.append(integrity / self.config.integrity_warning_threshold)
        
        if coherence >= 0.5:  # Reasonable coherence threshold
            compliance_factors.append(1.0)
        else:
            compliance_factors.append(coherence / 0.5)
        
        self.current_metrics.constitutional_compliance = np.mean(compliance_factors)
        
        # Calculate system stability (based on recent metrics variance)
        if len(self.metrics_history) >= 10:
            recent_ha = [m.hallucination_number for m in self.metrics_history[-10:]]
            ha_variance = np.var(recent_ha)
            stability = max(0, 1.0 - ha_variance)
            self.current_metrics.system_stability = stability
        else:
            self.current_metrics.system_stability = 1.0
        
        # Update risk factors
        self.current_metrics.risk_factors = []
        
        if ha > self.config.ha_warning_threshold:
            self.current_metrics.risk_factors.append(f"High Ha: {ha:.3f}")
        
        if integrity < self.config.integrity_warning_threshold:
            self.current_metrics.risk_factors.append(f"Low integrity: {integrity:.3f}")
        
        if coherence < 0.3:
            self.current_metrics.risk_factors.append(f"Low coherence: {coherence:.3f}")
        
        if self.emergency_active:
            self.current_metrics.risk_factors.append("Emergency protocols active")
    
    def _update_system_status(self):
        """Update overall system status based on current metrics"""
        ha = self.current_metrics.hallucination_number
        integrity = self.current_metrics.integrity_score
        threat = self.current_metrics.threat_level
        
        if self.emergency_active:
            self.current_status = ConstitutionalStatus.EMERGENCY
        elif self.recovery_mode_active:
            self.current_status = ConstitutionalStatus.RECOVERY
        elif ha >= self.config.ha_failure_threshold or integrity <= self.config.integrity_failure_threshold:
            self.current_status = ConstitutionalStatus.FAILURE
        elif ha >= self.config.ha_critical_threshold or integrity <= self.config.integrity_critical_threshold:
            self.current_status = ConstitutionalStatus.CRITICAL
        elif ha >= self.config.ha_warning_threshold or integrity <= self.config.integrity_warning_threshold:
            self.current_status = ConstitutionalStatus.WARNING
        elif threat in [ThreatLevel.MODERATE, ThreatLevel.HIGH]:
            self.current_status = ConstitutionalStatus.MONITORING
        else:
            self.current_status = ConstitutionalStatus.NORMAL
            # Exit recovery mode if system is stable
            if self.recovery_mode_active:
                self.recovery_mode_active = False
                logger.info("Recovery mode completed, returning to normal operation")
    
    async def _alert_evaluation_loop(self):
        """Evaluate and manage alerts"""
        while self.monitoring_active:
            try:
                await self._evaluate_alerts()
                await asyncio.sleep(self.config.alert_evaluation_interval_ms / 1000.0)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Alert evaluation error: {e}")
    
    async def _evaluate_alerts(self):
        """Evaluate current metrics and generate/resolve alerts"""
        current_time = time.time()
        
        # Generate new alerts based on thresholds
        await self._check_ha_alerts()
        await self._check_integrity_alerts()
        await self._check_performance_alerts()
        
        # Auto-resolve alerts if conditions improved
        resolved_alerts = []
        for alert_id, alert in self.active_alerts.items():
            if await self._should_resolve_alert(alert):
                alert.auto_resolved = True
                alert.resolution_time = current_time
                resolved_alerts.append(alert_id)
        
        # Remove resolved alerts
        for alert_id in resolved_alerts:
            resolved_alert = self.active_alerts.pop(alert_id)
            logger.info(f"Auto-resolved alert: {resolved_alert.title}")
    
    async def _check_ha_alerts(self):
        """Check for Ha-related alerts"""
        ha = self.current_metrics.hallucination_number
        
        if ha >= self.config.ha_critical_threshold and 'ha_critical' not in self.active_alerts:
            alert = ConstitutionalAlert(
                alert_id='ha_critical',
                severity=ThreatLevel.CRITICAL,
                title=f"Critical Hallucination Number: {ha:.3f}",
                description=f"Ha value {ha:.3f} exceeds critical threshold {self.config.ha_critical_threshold}",
                affected_modules=['all'],
                recommended_actions=[
                    "Review input data quality",
                    "Check symbolic consistency",
                    "Consider emergency reset"
                ],
                metrics_snapshot=self.current_metrics
            )
            self.active_alerts['ha_critical'] = alert
            logger.critical(f"ALERT: {alert.title}")
        
        elif ha >= self.config.ha_warning_threshold and 'ha_warning' not in self.active_alerts:
            alert = ConstitutionalAlert(
                alert_id='ha_warning',
                severity=ThreatLevel.MODERATE,
                title=f"Elevated Hallucination Number: {ha:.3f}",
                description=f"Ha value {ha:.3f} exceeds warning threshold {self.config.ha_warning_threshold}",
                affected_modules=['esc', 'symbolic'],
                recommended_actions=[
                    "Increase monitoring frequency",
                    "Review semantic processing",
                    "Check for input anomalies"
                ],
                metrics_snapshot=self.current_metrics
            )
            self.active_alerts['ha_warning'] = alert
            logger.warning(f"ALERT: {alert.title}")
    
    async def _check_integrity_alerts(self):
        """Check for integrity-related alerts"""
        integrity = self.current_metrics.integrity_score
        
        if integrity <= self.config.integrity_critical_threshold and 'integrity_critical' not in self.active_alerts:
            alert = ConstitutionalAlert(
                alert_id='integrity_critical',
                severity=ThreatLevel.CRITICAL,
                title=f"Critical Integrity Loss: {integrity:.3f}",
                description=f"System integrity {integrity:.3f} below critical threshold {self.config.integrity_critical_threshold}",
                affected_modules=['constitutional', 'all'],
                recommended_actions=[
                    "Activate forced synchronization",
                    "Review constitutional constraints",
                    "Investigate integrity violations"
                ],
                metrics_snapshot=self.current_metrics
            )
            self.active_alerts['integrity_critical'] = alert
            logger.critical(f"ALERT: {alert.title}")
    
    async def _check_performance_alerts(self):
        """Check for performance-related alerts"""
        latency = self.current_metrics.processing_latency_ms
        
        if latency > self.config.max_processing_latency_ms and 'performance_latency' not in self.active_alerts:
            alert = ConstitutionalAlert(
                alert_id='performance_latency',
                severity=ThreatLevel.MODERATE,
                title=f"High Processing Latency: {latency:.1f}ms",
                description=f"Processing latency {latency:.1f}ms exceeds threshold {self.config.max_processing_latency_ms}ms",
                affected_modules=['all'],
                recommended_actions=[
                    "Check system resources",
                    "Review processing complexity",
                    "Consider optimization"
                ],
                metrics_snapshot=self.current_metrics
            )
            self.active_alerts['performance_latency'] = alert
            logger.warning(f"ALERT: {alert.title}")
    
    async def _should_resolve_alert(self, alert: ConstitutionalAlert) -> bool:
        """Determine if an alert should be auto-resolved"""
        ha = self.current_metrics.hallucination_number
        integrity = self.current_metrics.integrity_score
        latency = self.current_metrics.processing_latency_ms
        
        # Resolution conditions based on alert type
        if alert.alert_id == 'ha_critical' and ha < self.config.ha_warning_threshold:
            return True
        elif alert.alert_id == 'ha_warning' and ha < self.config.ha_warning_threshold * 0.8:
            return True
        elif alert.alert_id == 'integrity_critical' and integrity > self.config.integrity_warning_threshold:
            return True
        elif alert.alert_id == 'performance_latency' and latency < self.config.max_processing_latency_ms * 0.8:
            return True
        
        return False
    
    async def _store_metrics(self):
        """Store current metrics to database"""
        if not self.config.enable_metrics_persistence:
            return
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    INSERT OR REPLACE INTO metrics 
                    (timestamp, hallucination_number, coherence_measure, defect_density, 
                     field_energy, integrity_score, threat_level, data_json)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    self.current_metrics.timestamp,
                    self.current_metrics.hallucination_number,
                    self.current_metrics.coherence_measure,
                    self.current_metrics.defect_density,
                    self.current_metrics.field_energy,
                    self.current_metrics.integrity_score,
                    self.current_metrics.threat_level.name,
                    json.dumps(self.current_metrics.to_dict())
                ))
        except Exception as e:
            logger.error(f"Metrics storage error: {e}")
    
    async def _start_websocket_server(self):
        """Start WebSocket server for real-time dashboard"""
        try:
            self.websocket_server = await websockets.serve(
                self._handle_websocket_connection,
                "localhost",
                self.config.dashboard_port
            )
            logger.info(f"WebSocket dashboard server started on port {self.config.dashboard_port}")
        except Exception as e:
            logger.error(f"WebSocket server start error: {e}")
    
    async def _handle_websocket_connection(self, websocket, path):
        """Handle WebSocket client connections"""
        if len(self.websocket_clients) >= self.config.max_websocket_connections:
            await websocket.close(code=1008, reason="Connection limit reached")
            return
        
        self.websocket_clients.add(websocket)
        logger.info(f"Dashboard client connected: {websocket.remote_address}")
        
        try:
            # Send initial state
            await websocket.send(json.dumps({
                'type': 'initial_state',
                'status': self.current_status.value,
                'metrics': self.current_metrics.to_dict(),
                'alerts': {k: v.to_dict() for k, v in self.active_alerts.items()}
            }))
            
            # Keep connection alive
            async for message in websocket:
                # Handle client messages (e.g., commands, requests)
                pass
                
        except websockets.exceptions.ConnectionClosed:
            pass
        except Exception as e:
            logger.error(f"WebSocket connection error: {e}")
        finally:
            self.websocket_clients.discard(websocket)
            logger.info(f"Dashboard client disconnected: {websocket.remote_address}")
    
    async def _broadcast_metrics(self):
        """Broadcast current metrics to all connected WebSocket clients"""
        if not self.websocket_clients:
            return
        
        message = json.dumps({
            'type': 'metrics_update',
            'status': self.current_status.value,
            'metrics': self.current_metrics.to_dict(),
            'alerts': {k: v.to_dict() for k, v in self.active_alerts.items()},
            'emergency_active': self.emergency_active,
            'recovery_mode': self.recovery_mode_active
        })
        
        # Send to all connected clients
        disconnected_clients = set()
        for websocket in self.websocket_clients:
            try:
                await websocket.send(message)
            except websockets.exceptions.ConnectionClosed:
                disconnected_clients.add(websocket)
            except Exception as e:
                logger.error(f"WebSocket broadcast error: {e}")
                disconnected_clients.add(websocket)
        
        # Remove disconnected clients
        self.websocket_clients -= disconnected_clients
    
    async def _safe_callback(self, callback: Callable, *args) -> Any:
        """Safely execute callback with error handling"""
        try:
            if asyncio.iscoroutinefunction(callback):
                return await callback(*args)
            else:
                return callback(*args)
        except Exception as e:
            logger.error(f"Callback execution error: {e}")
            return None
    
    # Public API methods
    
    async def force_emergency_mode(self, reason: str = "Manual activation"):
        """Manually activate emergency mode"""
        if not self.emergency_active:
            self.emergency_active = True
            self.emergency_start_time = time.time()
            
            alert = ConstitutionalAlert(
                alert_id='manual_emergency',
                severity=ThreatLevel.EXTREME,
                title="Manual Emergency Activation",
                description=f"Emergency mode manually activated: {reason}",
                affected_modules=['all'],
                recommended_actions=["Review system state", "Investigate emergency cause"],
                metrics_snapshot=self.current_metrics
            )
            self.active_alerts['manual_emergency'] = alert
            
            if self.emergency_callback:
                await self._safe_callback(self.emergency_callback, {'activate': True})
            
            logger.critical(f"Manual emergency activation: {reason}")
    
    async def deactivate_emergency_mode(self, reason: str = "Manual deactivation"):
        """Manually deactivate emergency mode"""
        if self.emergency_active:
            self.emergency_active = False
            self.emergency_start_time = None
            self.recovery_mode_active = True
            
            if self.emergency_callback:
                await self._safe_callback(self.emergency_callback, {'activate': False})
            
            # Remove emergency alerts
            if 'manual_emergency' in self.active_alerts:
                self.active_alerts.pop('manual_emergency')
            
            logger.info(f"Manual emergency deactivation: {reason}")
    
    def get_current_status(self) -> Dict[str, Any]:
        """Get current constitutional monitoring status"""
        return {
            'status': self.current_status.value,
            'metrics': self.current_metrics.to_dict(),
            'alerts_count': len(self.active_alerts),
            'active_alerts': {k: v.to_dict() for k, v in self.active_alerts.items()},
            'emergency_active': self.emergency_active,
            'recovery_mode': self.recovery_mode_active,
            'monitoring_active': self.monitoring_active,
            'uptime_seconds': time.time() - (self.emergency_start_time or time.time())
        }
    
    def get_metrics_history(self, 
                          hours: int = 1, 
                          include_alerts: bool = True) -> Dict[str, Any]:
        """Get historical metrics and alerts"""
        cutoff_time = time.time() - (hours * 3600)
        
        # Filter metrics by time
        filtered_metrics = [
            m.to_dict() for m in self.metrics_history 
            if m.timestamp >= cutoff_time
        ]
        
        result = {
            'metrics': filtered_metrics,
            'time_range_hours': hours,
            'total_points': len(filtered_metrics)
        }
        
        if include_alerts:
            # Get alerts from database if available
            result['alerts'] = self._get_historical_alerts(cutoff_time)
        
        return result
    
    def _get_historical_alerts(self, cutoff_time: float) -> List[Dict[str, Any]]:
        """Get historical alerts from database"""
        if not self.config.enable_metrics_persistence:
            return []
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute("""
                    SELECT alert_id, timestamp, severity, title, description, 
                           auto_resolved, resolution_time, data_json
                    FROM alerts 
                    WHERE timestamp >= ?
                    ORDER BY timestamp DESC
                """, (cutoff_time,))
                
                alerts = []
                for row in cursor.fetchall():
                    alert_data = {
                        'alert_id': row[0],
                        'timestamp': row[1],
                        'severity': row[2],
                        'title': row[3],
                        'description': row[4],
                        'auto_resolved': bool(row[5]),
                        'resolution_time': row[6]
                    }
                    
                    # Parse JSON data if available
                    if row[7]:
                        try:
                            alert_data.update(json.loads(row[7]))
                        except:
                            pass
                    
                    alerts.append(alert_data)
                
                return alerts
                
        except Exception as e:
            logger.error(f"Historical alerts retrieval error: {e}")
            return []


# Test function for constitutional monitoring
async def test_constitutional_monitoring():
    """Test constitutional monitoring system"""
    print("🏛️ Testing Constitutional Real-time Monitoring System")
    
    # Create monitor with test configuration
    config = ConstitutionalConfiguration()
    config.ha_warning_threshold = 0.5
    config.ha_critical_threshold = 1.0
    config.monitoring_interval_ms = 1000  # 1 second for testing
    
    monitor = ConstitutionalRealTimeMonitor(config)
    
    # Mock callback functions
    async def mock_metrics_callback():
        import random
        return {
            'hallucination_number': random.uniform(0, 2.0),
            'coherence_measure': random.uniform(0.3, 1.0),
            'defect_density': random.uniform(0, 0.1),
            'field_energy': random.uniform(0, 1000),
            'integrity_score': random.uniform(0.5, 1.0)
        }
    
    async def mock_control_callback(signals):
        print(f"📊 Control signals applied: {list(signals.keys())}")
    
    async def mock_emergency_callback(action):
        if action.get('activate'):
            print("🚨 EMERGENCY PROTOCOLS ACTIVATED")
        else:
            print("✅ Emergency protocols deactivated")
    
    # Start monitoring
    await monitor.start_monitoring(
        module_control_callback=mock_control_callback,
        emergency_callback=mock_emergency_callback,
        metrics_callback=mock_metrics_callback
    )
    
    print("📈 Monitoring started - check status for 10 seconds...")
    
    # Monitor for a few seconds
    for i in range(10):
        await asyncio.sleep(1)
        status = monitor.get_current_status()
        print(f"Status: {status['status']}, Ha: {status['metrics']['hallucination_number']:.3f}, "
              f"Alerts: {status['alerts_count']}")
    
    # Stop monitoring
    await monitor.stop_monitoring()
    print("✅ Constitutional monitoring test completed")


if __name__ == "__main__":
    asyncio.run(test_constitutional_monitoring())