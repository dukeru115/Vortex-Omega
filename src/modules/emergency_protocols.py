"""
Emergency Protocols for NFCS - Protection System
===============================================

High-level emergency state management system with detailed
ENTER/EXIT EMERGENCY protocols, smooth transitions and system recovery.

Key Capabilities:
- Detection of emergency states and automatic activation of protective measures
- ENTER EMERGENCY protocols: isolation, connection strengthening, cross-link suppression
- EXIT EMERGENCY protocols: smooth recovery, stability verification
- Specialized measures for each component: Boundary, Kuramoto, ESC, CGL
- Telemetry and logging of all emergency operations
- Integration with resonance bus and constitution
"""

import asyncio
import logging
import time
import threading
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Callable, Tuple
import numpy as np

from ..core.state import SystemState, RiskMetrics
from ..modules.risk_monitor import RiskLevel
from ..modules.constitution_v0 import ControlIntent, DecisionType
from ..orchestrator.resonance_bus import (
    get_global_bus,
    TopicType,
    EventPriority,
    BusEvent,
    EmergencyPayload,
    TelemetryPayload,
    publish_emergency,
)


class EmergencyPhase(Enum):
    """Emergency mode phases"""

    NORMAL = "NORMAL"  # Normal operation
    DETECTION = "DETECTION"  # Emergency situation detection
    ENTERING = "ENTERING"  # Entering emergency mode
    ACTIVE = "ACTIVE"  # Active emergency mode
    RECOVERY_ASSESSMENT = "RECOVERY_ASSESSMENT"  # Recovery possibility assessment
    EXITING = "EXITING"  # Exiting emergency mode
    STABILIZATION = "STABILIZATION"  # Stabilization after exit


class EmergencyTrigger(Enum):
    """Emergency situation triggers"""

    HIGH_HALLUCINATION_NUMBER = "HIGH_HALLUCINATION_NUMBER"
    EXCESSIVE_DEFECT_DENSITY = "EXCESSIVE_DEFECT_DENSITY"
    COHERENCE_COLLAPSE = "COHERENCE_COLLAPSE"
    SYSTEM_INSTABILITY = "SYSTEM_INSTABILITY"
    CONSTITUTIONAL_VIOLATION = "CONSTITUTIONAL_VIOLATION"
    MANUAL_TRIGGER = "MANUAL_TRIGGER"
    CASCADING_FAILURE = "CASCADING_FAILURE"
    TIMEOUT_RECOVERY = "TIMEOUT_RECOVERY"


class ComponentProtocol(Enum):
    """Protocols for specific components"""

    BOUNDARY_ISOLATION = "BOUNDARY_ISOLATION"
    KURAMOTO_CLUSTERING = "KURAMOTO_CLUSTERING"
    ESC_NORMALIZATION = "ESC_NORMALIZATION"
    CGL_STABILIZATION = "CGL_STABILIZATION"
    CROSS_TALK_SUPPRESSION = "CROSS_TALK_SUPPRESSION"
    COHERENCE_ENFORCEMENT = "COHERENCE_ENFORCEMENT"


@dataclass
class EmergencyAction:
    """Action in emergency protocol"""

    protocol: ComponentProtocol
    target_component: str
    action_type: str  # activate, deactivate, adjust, monitor
    parameters: Dict[str, Any] = field(default_factory=dict)
    priority: int = 1  # 1-5, where 5 is critical
    estimated_duration: float = 10.0  # Expected duration (sec)
    prerequisites: List[str] = field(default_factory=list)  # Dependencies
    success_criteria: Dict[str, float] = field(default_factory=dict)
    rollback_action: Optional["EmergencyAction"] = None


@dataclass
class ProtocolExecution:
    """Protocol execution information"""

    action: EmergencyAction
    started_at: float = field(default_factory=time.time)
    completed_at: Optional[float] = None
    success: Optional[bool] = None
    error_message: Optional[str] = None

    def get_duration(self) -> float:
        """Get execution duration"""
        end_time = self.completed_at or time.time()
        return end_time - self.started_at

    def is_completed(self) -> bool:
        """Check if execution is completed"""
        return self.completed_at is not None

    def is_successful(self) -> bool:
        """Check if execution was successful"""
        return self.success is True


@dataclass
class EmergencyState:
    """Emergency protocols system state"""

    current_phase: EmergencyPhase = EmergencyPhase.NORMAL
    active_triggers: List[EmergencyTrigger] = field(default_factory=list)
    emergency_start_time: Optional[float] = None
    last_phase_change: float = field(default_factory=time.time)

    # Active protocols and their execution
    active_protocols: Dict[ComponentProtocol, ProtocolExecution] = field(default_factory=dict)
    completed_protocols: List[ProtocolExecution] = field(default_factory=list)
    failed_protocols: List[ProtocolExecution] = field(default_factory=list)

    # State metrics
    stabilization_progress: float = 0.0  # Stabilization progress [0-1]
    recovery_readiness: float = 0.0  # Recovery readiness [0-1]
    system_coherence_target: float = 0.7  # Target coherence for recovery

    # Counters and statistics
    total_emergencies: int = 0
    successful_recoveries: int = 0
    failed_recoveries: int = 0
    avg_recovery_time: float = 0.0

    def get_emergency_duration(self) -> float:
        """Get current emergency mode duration"""
        if self.emergency_start_time is None:
            return 0.0
        return time.time() - self.emergency_start_time

    def get_phase_duration(self) -> float:
        """Get current phase duration"""
        return time.time() - self.last_phase_change

    def is_in_emergency(self) -> bool:
        """Check if system is in emergency mode"""
        return self.current_phase not in [EmergencyPhase.NORMAL, EmergencyPhase.STABILIZATION]


class EmergencyProtocols:
    """
    Emergency protocols system for NFCS

    Manages detection, processing and recovery from emergency states
    with coordination of all system components through detailed protocols.
    """

    def __init__(
        self,
        enable_auto_detection: bool = True,
        enable_auto_recovery: bool = True,
        max_emergency_duration: float = 600.0,
        stabilization_timeout: float = 120.0,
        recovery_assessment_interval: float = 30.0,
    ):

        self.enable_auto_detection = enable_auto_detection
        self.enable_auto_recovery = enable_auto_recovery
        self.max_emergency_duration = max_emergency_duration
        self.stabilization_timeout = stabilization_timeout
        self.recovery_assessment_interval = recovery_assessment_interval

        # System state
        self.state = EmergencyState()

        # Thread safety
        self._lock = threading.RLock()

        # Resonance bus
        self.bus = get_global_bus()

        # Logger
        self.logger = logging.getLogger(f"{__name__}.EmergencyProtocols")

        # Predefined protocols
        self._initialize_emergency_protocols()

        # Event subscriptions
        if self.enable_auto_detection:
            self._subscribe_to_events()

        # Background tasks
        self._monitoring_task: Optional[asyncio.Task] = None
        self._running = False

        self.logger.info("Emergency protocols system initialized")

    def _initialize_emergency_protocols(self):
        """Initialize predefined emergency protocols"""

        self.emergency_protocols = {
            # Boundary isolation protocol
            ComponentProtocol.BOUNDARY_ISOLATION: EmergencyAction(
                protocol=ComponentProtocol.BOUNDARY_ISOLATION,
                target_component="boundary",
                action_type="adjust",
                parameters={
                    "permeability_multiplier": 0.1,  # Reduce permeability to 10%
                    "trust_threshold_increase": 0.3,  # Increase trust threshold
                    "novelty_suppression": 0.8,  # Novelty suppression
                    "threat_sensitivity": 2.0,  # Increase threat sensitivity
                },
                priority=5,
                estimated_duration=5.0,
                success_criteria={"permeability_achieved": 0.1, "isolation_effective": True},
            ),
            # Kuramoto clustering protocol
            ComponentProtocol.KURAMOTO_CLUSTERING: EmergencyAction(
                protocol=ComponentProtocol.KURAMOTO_CLUSTERING,
                target_component="kuramoto",
                action_type="adjust",
                parameters={
                    "intra_cluster_boost": 2.0,  # Strengthen intra-cluster connections
                    "inter_cluster_suppression": 0.3,  # Weaken inter-cluster connections
                    "self_coupling_boost": 1.5,  # Strengthen self-coupling
                    "frequency_lock": True,  # Frequency locking
                },
                priority=4,
                estimated_duration=10.0,
                success_criteria={"clustering_coefficient": 0.8, "synchronization_stable": True},
            ),
            # ESC normalization protocol
            ComponentProtocol.ESC_NORMALIZATION: EmergencyAction(
                protocol=ComponentProtocol.ESC_NORMALIZATION,
                target_component="esc",
                action_type="adjust",
                parameters={
                    "normalization_mode": "strict",  # Strict normalization
                    "order_parameter_limit": 0.7,  # Order parameter limitation
                    "resonance_damping": 0.4,  # Resonance damping
                    "semantic_filtering": True,  # Semantic filtering
                    "alpha_lock": True,  # Î±-locking
                },
                priority=3,
                estimated_duration=8.0,
                success_criteria={"order_param_stable": True, "resonance_controlled": True},
            ),
            # CGL stabilization protocol
            ComponentProtocol.CGL_STABILIZATION: EmergencyAction(
                protocol=ComponentProtocol.CGL_STABILIZATION,
                target_component="cgl",
                action_type="adjust",
                parameters={
                    "energy_penalty_multiplier": 5.0,  # Increase energy penalties
                    "spatial_smoothing": 0.3,  # Spatial smoothing
                    "temporal_damping": 0.2,  # Temporal damping
                    "amplitude_clipping": 0.8,  # Amplitude clipping
                    "diffusion_boost": 1.5,  # Diffusion boost
                },
                priority=4,
                estimated_duration=15.0,
                success_criteria={"field_stable": True, "energy_controlled": True},
            ),
            # Cross-talk suppression protocol
            ComponentProtocol.CROSS_TALK_SUPPRESSION: EmergencyAction(
                protocol=ComponentProtocol.CROSS_TALK_SUPPRESSION,
                target_component="system",
                action_type="adjust",
                parameters={
                    "cross_talk_multiplier": 0.2,  # Suppress to 20%
                    "module_isolation": True,  # Module isolation
                    "communication_filtering": True,  # Communication filtering
                    "signal_attenuation": 0.7,  # Signal attenuation
                },
                priority=3,
                estimated_duration=12.0,
                success_criteria={"cross_talk_reduced": True, "isolation_effective": True},
            ),
            # Forced coherence protocol
            ComponentProtocol.COHERENCE_ENFORCEMENT: EmergencyAction(
                protocol=ComponentProtocol.COHERENCE_ENFORCEMENT,
                target_component="system",
                action_type="activate",
                parameters={
                    "coherence_target": 0.7,  # Ð¦ÐµÐ»ÐµÐ²Ð°Ñ coherence
                    "enforcement_strength": 0.8,  # Ð¡Ð¸Ð»Ð° Ð¿ÑÐ¸Ð½ÑÐ¶Ð´ÐµÐ½Ð¸Ñ
                    "gradient_suppression": True,  # ÐÐ¾Ð´Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð³ÑÐ°Ð´Ð¸ÐµÐ½ÑÐ¾Ð²
                    "phase_locking": True,  # ÐÐ»Ð¾ÐºÐ¸ÑÐ¾Ð²ÐºÐ° ÑÐ°Ð·
                },
                priority=2,
                estimated_duration=20.0,
                success_criteria={"coherence_achieved": 0.7, "stability_maintained": True},
            ),
        }

    def _subscribe_to_events(self):
        """ÐÐ¾Ð´Ð¿Ð¸ÑÐ°ÑÑÑÑ Ð½Ð° ÑÐ¾Ð±ÑÑÐ¸Ñ Ð´Ð»Ñ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¾Ð¹ Ð´ÐµÑÐµÐºÑÐ¸Ð¸"""

        try:
            # ÐÐ¾Ð´Ð¿Ð¸ÑÐºÐ° Ð½Ð° Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÐµ ÑÐ¾Ð±ÑÑÐ¸Ñ
            self.bus.subscribe(
                handler_id="emergency_protocols_handler",
                callback=self._handle_emergency_event,
                topic_filter={TopicType.ORCHESTRATION_EMERGENCY},
                priority_filter={EventPriority.EMERGENCY, EventPriority.CRITICAL},
            )

            # ÐÐ¾Ð´Ð¿Ð¸ÑÐºÐ° Ð½Ð° ÑÐ¾Ð±ÑÑÐ¸Ñ ÑÐ¸ÑÐºÐ¾Ð² Ð´Ð»Ñ Ð¿ÑÐµÐ´Ð¸ÐºÑÐ¸Ð²Ð½Ð¾Ð¹ Ð´ÐµÑÐµÐºÑÐ¸Ð¸
            self.bus.subscribe(
                handler_id="emergency_risk_handler",
                callback=self._handle_risk_event,
                topic_filter={TopicType.METRICS_RISK},
                priority_filter={EventPriority.CRITICAL, EventPriority.EMERGENCY},
            )

            self.logger.info("ÐÐ¾Ð´Ð¿Ð¸ÑÐºÐ° Ð½Ð° Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÐµ ÑÐ¾Ð±ÑÑÐ¸Ñ Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°Ð½Ð°")

        except Exception as e:
            self.logger.error(f"Error Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸ Ð½Ð° ÑÐ¾Ð±ÑÑÐ¸Ñ: {e}")

    def _handle_emergency_event(self, event: BusEvent):
        """ÐÐ±ÑÐ°Ð±Ð¾ÑÑÐ¸Ðº Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ ÑÐ¾Ð±ÑÑÐ¸Ð¹"""

        try:
            if isinstance(event.payload, EmergencyPayload):
                emergency_type = event.payload.emergency_type
                severity = event.payload.severity_level
                reason = event.payload.trigger_reason

                self.logger.critical(
                    f"ÐÐ¾Ð»ÑÑÐµÐ½Ð¾ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ðµ ÑÐ¾Ð±ÑÑÐ¸Ðµ: {emergency_type} "
                    f"(severity={severity}) - {reason}"
                )

                # ÐÐ¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÑÑÐ¸Ð³Ð³ÐµÑÐ° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÐ¸Ð¿Ð° ÑÐ¾Ð±ÑÑÐ¸Ñ
                trigger = self._map_emergency_type_to_trigger(emergency_type)

                # Start Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð² ÐµÑÐ»Ð¸ Ð½Ðµ Ð°ÐºÑÐ¸Ð²Ð½Ñ
                if not self.state.is_in_emergency():
                    asyncio.create_task(self.enter_emergency_mode(trigger, reason))

        except Exception as e:
            self.logger.error(f"Error Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð±ÑÑÐ¸Ñ: {e}")

    def _handle_risk_event(self, event: BusEvent):
        """ÐÐ±ÑÐ°Ð±Ð¾ÑÑÐ¸Ðº ÑÐ¾Ð±ÑÑÐ¸Ð¹ ÑÐ¸ÑÐºÐ¾Ð² Ð´Ð»Ñ Ð¿ÑÐµÐ´Ð¸ÐºÑÐ¸Ð²Ð½Ð¾Ð¹ Ð´ÐµÑÐµÐºÑÐ¸Ð¸"""

        try:
            from ..orchestrator.resonance_bus import RiskMetricsPayload

            if isinstance(event.payload, RiskMetricsPayload):
                risk_level = RiskLevel(event.payload.risk_level)

                # ÐÑÐµÐ´Ð¸ÐºÑÐ¸Ð²Ð½Ð°Ñ Ð´ÐµÑÐµÐºÑÐ¸Ñ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÐºÑÐ¸ÑÐ¸ÑÐµÑÐºÐ¸Ñ ÑÐ¸ÑÐºÐ¾Ð²
                if risk_level == RiskLevel.EMERGENCY and not self.state.is_in_emergency():

                    # ÐÐ¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ ÑÑÐ¸Ð³Ð³ÐµÑÐ° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¼ÐµÑÑÐ¸Ðº
                    trigger = self._analyze_risk_trigger(event.payload)
                    reason = f"Predictive detection: {risk_level.value}"

                    asyncio.create_task(self.enter_emergency_mode(trigger, reason))

        except Exception as e:
            self.logger.error(f"Error Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸ ÑÐ¾Ð±ÑÑÐ¸Ñ ÑÐ¸ÑÐºÐ°: {e}")

    def _map_emergency_type_to_trigger(self, emergency_type: str) -> EmergencyTrigger:
        """Ð¡Ð¾Ð¿Ð¾ÑÑÐ°Ð²Ð¸ÑÑ ÑÐ¸Ð¿ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð±ÑÑÐ¸Ñ Ñ ÑÑÐ¸Ð³Ð³ÐµÑÐ¾Ð¼"""

        mapping = {
            "HIGH_HALLUCINATION_NUMBER": EmergencyTrigger.HIGH_HALLUCINATION_NUMBER,
            "EXCESSIVE_DEFECT_DENSITY": EmergencyTrigger.EXCESSIVE_DEFECT_DENSITY,
            "COHERENCE_COLLAPSE": EmergencyTrigger.COHERENCE_COLLAPSE,
            "SYSTEMIC_RISK_CRITICAL": EmergencyTrigger.SYSTEM_INSTABILITY,
            "CONSTITUTIONAL_VIOLATION": EmergencyTrigger.CONSTITUTIONAL_VIOLATION,
            "MANUAL_EMERGENCY": EmergencyTrigger.MANUAL_TRIGGER,
        }

        return mapping.get(emergency_type, EmergencyTrigger.SYSTEM_INSTABILITY)

    def _analyze_risk_trigger(self, risk_payload) -> EmergencyTrigger:
        """ÐÐ½Ð°Ð»Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÑÐ¸Ð³Ð³ÐµÑ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¼ÐµÑÑÐ¸Ðº ÑÐ¸ÑÐºÐ°"""

        # ÐÑÐ¸Ð¾ÑÐ¸ÑÐµÑ Ð¿Ð¾ ÑÐµÑÑÐµÐ·Ð½Ð¾ÑÑÐ¸ ÑÐ³ÑÐ¾Ð·Ñ
        if risk_payload.hallucination_number > 0.9:
            return EmergencyTrigger.HIGH_HALLUCINATION_NUMBER
        elif risk_payload.defect_density_mean > 0.2:
            return EmergencyTrigger.EXCESSIVE_DEFECT_DENSITY
        elif risk_payload.coherence_global < 0.2 or risk_payload.coherence_modular < 0.2:
            return EmergencyTrigger.COHERENCE_COLLAPSE
        else:
            return EmergencyTrigger.SYSTEM_INSTABILITY

    async def start_monitoring(self):
        """Start ÑÐ¾Ð½Ð¾Ð²ÑÐ¹ monitoring Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¹"""

        if self._running:
            return

        self._running = True
        self._monitoring_task = asyncio.create_task(self._monitoring_loop())
        self.logger.info("Monitoring Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¹ started")

    async def stop_monitoring(self):
        """Stop ÑÐ¾Ð½Ð¾Ð²ÑÐ¹ monitoring"""

        if not self._running:
            return

        self._running = False
        if self._monitoring_task:
            self._monitoring_task.cancel()
            try:
                await self._monitoring_task
            except asyncio.CancelledError:
                pass

        self.logger.info("Monitoring Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¹ stopped")

    async def _monitoring_loop(self):
        """ÐÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÐ¸ÐºÐ» Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ¸Ð½Ð³Ð°"""

        while self._running:
            try:
                with self._lock:
                    current_phase = self.state.current_phase
                    phase_duration = self.state.get_phase_duration()

                # Processing Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐ¸ Ð¾Ñ ÑÐµÐºÑÑÐµÐ¹ ÑÐ°Ð·Ñ
                if current_phase == EmergencyPhase.ACTIVE:
                    await self._monitor_active_emergency()

                elif current_phase == EmergencyPhase.RECOVERY_ASSESSMENT:
                    await self._assess_recovery_readiness()

                elif current_phase == EmergencyPhase.STABILIZATION:
                    await self._monitor_stabilization()

                # Check ÑÐ°Ð¹Ð¼-Ð°ÑÑÐ¾Ð²
                await self._check_timeouts()

                # Pause
                await asyncio.sleep(5.0)

            except Exception as e:
                self.logger.error(f"Error Ð² ÑÐ¸ÐºÐ»Ðµ Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ¸Ð½Ð³Ð°: {e}")
                await asyncio.sleep(1.0)

    async def _monitor_active_emergency(self):
        """Monitoring Ð°ÐºÑÐ¸Ð²Ð½Ð¾Ð³Ð¾ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°"""

        with self._lock:
            # Check Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¸Ñ Ð°ÐºÑÐ¸Ð²Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
            completed_protocols = []
            for protocol, execution in self.state.active_protocols.items():
                if execution.is_completed():
                    completed_protocols.append(protocol)

                    if execution.is_successful():
                        self.state.completed_protocols.append(execution)
                        self.logger.info(f"Protocol {protocol.value} completed successfully")
                    else:
                        self.state.failed_protocols.append(execution)
                        self.logger.error(
                            f"Protocol {protocol.value} completed Ñ Ð¾ÑÐ¸Ð±ÐºÐ¾Ð¹: {execution.error_message}"
                        )

            # Deletion Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð² Ð¸Ð· Ð°ÐºÑÐ¸Ð²Ð½ÑÑ
            for protocol in completed_protocols:
                del self.state.active_protocols[protocol]

            # ÐÑÐ»Ð¸ Ð²ÑÐµ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ñ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ñ, Ð¿ÐµÑÐµÑÐ¾Ð´ Ðº Ð¾ÑÐµÐ½ÐºÐµ Ð²Ð¾ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ
            if not self.state.active_protocols and self.enable_auto_recovery:
                await self._transition_to_recovery_assessment()

    async def _assess_recovery_readiness(self):
        """ÐÑÐµÐ½Ð¸ÑÑ readiness Ðº Ð²Ð¾ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ"""

        # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ Ð¾ÑÐµÐ½ÐºÐ¸ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ ÑÐ¸ÑÑÐµÐ¼Ñ
        # Ð ÑÐµÐ°Ð»ÑÐ½Ð¾Ð¹ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð·Ð´ÐµÑÑ Ð´Ð¾Ð»Ð¶Ð½Ñ Ð±ÑÑÑ Ð¿ÑÐ¾Ð²ÐµÑÐºÐ¸ Ð¼ÐµÑÑÐ¸Ðº

        with self._lock:
            # ÐÑÐ¾ÑÑÐ°Ñ ÑÐ²ÑÐ¸ÑÑÐ¸ÐºÐ° Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð¸ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
            successful_protocols = len(self.state.completed_protocols)
            total_protocols = successful_protocols + len(self.state.failed_protocols)

            if total_protocols > 0:
                success_rate = successful_protocols / total_protocols
                self.state.recovery_readiness = min(success_rate, 1.0)

            # ÐÑÐ»Ð¸ readiness Ð²ÑÑÐ¾ÐºÐ°Ñ, Ð½Ð°ÑÐ¸Ð½Ð°ÐµÐ¼ Ð²ÑÑÐ¾Ð´
            if self.state.recovery_readiness >= 0.7:
                await self.exit_emergency_mode("Recovery readiness achieved")

    async def _monitor_stabilization(self):
        """Monitoring ÑÑÐ°Ð±Ð¸Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð¿Ð¾ÑÐ»Ðµ Ð²ÑÑÐ¾Ð´Ð° Ð¸Ð· Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°"""

        with self._lock:
            phase_duration = self.state.get_phase_duration()

            # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ Ð¿ÑÐ¾Ð³ÑÐµÑÑÐ° ÑÑÐ°Ð±Ð¸Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸
            self.state.stabilization_progress = min(
                phase_duration / self.stabilization_timeout, 1.0
            )

            # ÐÑÐ»Ð¸ stabilization completed
            if self.state.stabilization_progress >= 1.0:
                await self._transition_to_normal()

    async def _check_timeouts(self):
        """Check ÑÐ°Ð·Ð»Ð¸ÑÐ½ÑÐµ ÑÐ°Ð¹Ð¼-Ð°ÑÑÑ"""

        with self._lock:
            emergency_duration = self.state.get_emergency_duration()

            # Ð¢Ð°Ð¹Ð¼-Ð°ÑÑ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°
            if self.state.is_in_emergency() and emergency_duration > self.max_emergency_duration:

                self.logger.critical(
                    f"Ð¢Ð°Ð¹Ð¼-Ð°ÑÑ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð° ({emergency_duration:.1f}Ñ), "
                    "Ð¿ÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½Ð¾Ðµ recovery"
                )

                await self.force_emergency_exit("Emergency timeout")

    async def enter_emergency_mode(
        self,
        trigger: EmergencyTrigger,
        reason: str,
        additional_context: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """
        ÐÐ¾Ð¹ÑÐ¸ Ð² emergency ÑÐµÐ¶Ð¸Ð¼

        Args:
            trigger: Ð¢ÑÐ¸Ð³Ð³ÐµÑ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð¹ ÑÐ¸ÑÑÐ°ÑÐ¸Ð¸
            reason: Reason Ð²ÑÐ¾Ð´Ð° Ð² emergency ÑÐµÐ¶Ð¸Ð¼
            additional_context: ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ ÐºÐ¾Ð½ÑÐµÐºÑÑ

        Returns:
            bool: True ÐµÑÐ»Ð¸ Ð²ÑÐ¾Ð´ Ð² emergency ÑÐµÐ¶Ð¸Ð¼ ÑÑÐ¿ÐµÑÐµÐ½
        """

        with self._lock:
            try:
                # Check, ÑÑÐ¾ Ð½Ðµ Ð½Ð°ÑÐ¾Ð´Ð¸Ð¼ÑÑ ÑÐ¶Ðµ Ð² Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð¼ ÑÐµÐ¶Ð¸Ð¼Ðµ
                if self.state.is_in_emergency():
                    self.logger.warning(
                        f"ÐÐ¾Ð¿ÑÑÐºÐ° Ð²ÑÐ¾Ð´Ð° Ð² emergency ÑÐµÐ¶Ð¸Ð¼, Ð½Ð¾ ÑÐ¶Ðµ Ð°ÐºÑÐ¸Ð²ÐµÐ½ "
                        f"ÑÐµÐ¶Ð¸Ð¼ {self.state.current_phase.value}"
                    )
                    return False

                # Update ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ
                self.state.current_phase = EmergencyPhase.ENTERING
                self.state.emergency_start_time = time.time()
                self.state.last_phase_change = time.time()
                self.state.total_emergencies += 1

                # ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÑÐ¸Ð³Ð³ÐµÑÐ°
                if trigger not in self.state.active_triggers:
                    self.state.active_triggers.append(trigger)

                # ÐÐ¾Ð³Ð³Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ
                self.logger.critical(
                    f"ð¨ ÐÐ¥ÐÐ Ð ÐÐÐÐ ÐÐÐÐ«Ð Ð ÐÐÐÐ ð¨\n"
                    f"Ð¢ÑÐ¸Ð³Ð³ÐµÑ: {trigger.value}\n"
                    f"Reason: {reason}\n"
                    f"ÐÐ¾Ð½ÑÐµÐºÑÑ: {additional_context}"
                )

                # ÐÑÐ±Ð»Ð¸ÐºÐ°ÑÐ¸Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð±ÑÑÐ¸Ñ
                await self._publish_emergency_status("EMERGENCY_ENTERING", reason, trigger.value)

                # ÐÐ¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¸ start Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
                protocols_to_activate = self._determine_emergency_protocols(trigger)

                # ÐÐºÑÐ¸Ð²Ð°ÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
                success = await self._activate_emergency_protocols(protocols_to_activate)

                if success:
                    # ÐÐµÑÐµÑÐ¾Ð´ Ð² active emergency ÑÐµÐ¶Ð¸Ð¼
                    self.state.current_phase = EmergencyPhase.ACTIVE
                    self.state.last_phase_change = time.time()

                    self.logger.critical(
                        f"Emergency ÑÐµÐ¶Ð¸Ð¼ Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°Ð½ Ñ {len(protocols_to_activate)} Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°Ð¼Ð¸"
                    )

                    return True
                else:
                    # ÐÑÐºÐ°Ñ Ð¿ÑÐ¸ Ð½ÐµÑÐ´Ð°ÑÐµ
                    await self._rollback_emergency_entry("Protocol activation failed")
                    return False

            except Exception as e:
                self.logger.error(f"Error Ð²ÑÐ¾Ð´Ð° Ð² emergency ÑÐµÐ¶Ð¸Ð¼: {e}")
                await self._rollback_emergency_entry(f"Entry error: {str(e)}")
                return False

    def _determine_emergency_protocols(self, trigger: EmergencyTrigger) -> List[ComponentProtocol]:
        """ÐÐ¿ÑÐµÐ´ÐµÐ»Ð¸ÑÑ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÐµ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ñ Ð´Ð»Ñ ÐºÐ¾Ð½ÐºÑÐµÑÐ½Ð¾Ð³Ð¾ ÑÑÐ¸Ð³Ð³ÐµÑÐ°"""

        protocol_map = {
            EmergencyTrigger.HIGH_HALLUCINATION_NUMBER: [
                ComponentProtocol.CGL_STABILIZATION,
                ComponentProtocol.ESC_NORMALIZATION,
                ComponentProtocol.COHERENCE_ENFORCEMENT,
            ],
            EmergencyTrigger.EXCESSIVE_DEFECT_DENSITY: [
                ComponentProtocol.CGL_STABILIZATION,
                ComponentProtocol.KURAMOTO_CLUSTERING,
                ComponentProtocol.CROSS_TALK_SUPPRESSION,
            ],
            EmergencyTrigger.COHERENCE_COLLAPSE: [
                ComponentProtocol.COHERENCE_ENFORCEMENT,
                ComponentProtocol.KURAMOTO_CLUSTERING,
                ComponentProtocol.ESC_NORMALIZATION,
            ],
            EmergencyTrigger.SYSTEM_INSTABILITY: [
                ComponentProtocol.BOUNDARY_ISOLATION,
                ComponentProtocol.KURAMOTO_CLUSTERING,
                ComponentProtocol.CROSS_TALK_SUPPRESSION,
                ComponentProtocol.CGL_STABILIZATION,
            ],
            EmergencyTrigger.CONSTITUTIONAL_VIOLATION: [
                ComponentProtocol.BOUNDARY_ISOLATION,
                ComponentProtocol.CROSS_TALK_SUPPRESSION,
            ],
            EmergencyTrigger.MANUAL_TRIGGER: [
                ComponentProtocol.BOUNDARY_ISOLATION,
                ComponentProtocol.KURAMOTO_CLUSTERING,
                ComponentProtocol.ESC_NORMALIZATION,
                ComponentProtocol.CGL_STABILIZATION,
            ],
            EmergencyTrigger.CASCADING_FAILURE: [
                ComponentProtocol.BOUNDARY_ISOLATION,
                ComponentProtocol.CROSS_TALK_SUPPRESSION,
                ComponentProtocol.COHERENCE_ENFORCEMENT,
                ComponentProtocol.CGL_STABILIZATION,
            ],
        }

        return protocol_map.get(
            trigger, [ComponentProtocol.BOUNDARY_ISOLATION, ComponentProtocol.CGL_STABILIZATION]
        )

    async def _activate_emergency_protocols(self, protocols: List[ComponentProtocol]) -> bool:
        """ÐÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²"""

        try:
            # Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð² Ð¿Ð¾ Ð¿ÑÐ¸Ð¾ÑÐ¸ÑÐµÑÑ
            sorted_protocols = sorted(
                protocols, key=lambda p: self.emergency_protocols[p].priority, reverse=True
            )

            successful_activations = 0

            for protocol in sorted_protocols:
                action = self.emergency_protocols[protocol]

                self.logger.info(f"ÐÐºÑÐ¸Ð²Ð°ÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð° {protocol.value}...")

                # Creation Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ
                execution = ProtocolExecution(action=action)
                self.state.active_protocols[protocol] = execution

                # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°
                success = await self._execute_protocol_action(action)

                # Update ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ°
                execution.completed_at = time.time()
                execution.success = success

                if success:
                    successful_activations += 1
                    self.logger.info(
                        f"Protocol {protocol.value} Ð°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°Ð½ successfully "
                        f"({execution.get_duration():.1f}Ñ)"
                    )
                else:
                    execution.error_message = "Activation failed"
                    self.logger.error(f"Error Ð°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð° {protocol.value}")

                # ÐÑÐ±Ð»Ð¸ÐºÐ°ÑÐ¸Ñ ÑÐµÐ»ÐµÐ¼ÐµÑÑÐ¸Ð¸
                await self._publish_protocol_telemetry(protocol, execution)

            # Check Ð¾Ð±ÑÐµÐ³Ð¾ ÑÑÐ¿ÐµÑÐ° (ÑÑÐµÐ±ÑÐµÑÑÑ Ð¼Ð¸Ð½Ð¸Ð¼ÑÐ¼ 50% ÑÑÐ¿ÐµÑÐ½ÑÑ Ð°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¹)
            success_rate = successful_activations / len(protocols) if protocols else 0
            return success_rate >= 0.5

        except Exception as e:
            self.logger.error(f"Error Ð°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²: {e}")
            return False

    async def _execute_protocol_action(self, action: EmergencyAction) -> bool:
        """Execute Ð´ÐµÐ¹ÑÑÐ²Ð¸Ðµ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°"""

        try:
            # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð° Ñ Ð·Ð°Ð´ÐµÑÐ¶ÐºÐ¾Ð¹
            await asyncio.sleep(min(action.estimated_duration * 0.1, 2.0))  # Ð£ÑÐºÐ¾ÑÐµÐ½Ð½Ð°Ñ Ð¸Ð¼Ð¸ÑÐ°ÑÐ¸Ñ

            # Ð ÑÐµÐ°Ð»ÑÐ½Ð¾Ð¹ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð·Ð´ÐµÑÑ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ:
            # 1. ÐÐ·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑÐ²Ð¸Ðµ Ñ ÐºÐ¾Ð½ÐºÑÐµÑÐ½ÑÐ¼Ð¸ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½ÑÐ°Ð¼Ð¸ (CGL, Kuramoto, ESC, Boundary)
            # 2. ÐÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² Ð¸Ð· action.parameters
            # 3. Check ÐºÑÐ¸ÑÐµÑÐ¸ÐµÐ² ÑÑÐ¿ÐµÑÐ° Ð¸Ð· action.success_criteria

            component = action.target_component
            parameters = action.parameters

            self.logger.debug(f"Execution {action.action_type} Ð´Ð»Ñ {component}: {parameters}")

            # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ ÑÑÐ¿ÐµÑÐ° (Ð² ÑÐµÐ°Ð»ÑÐ½Ð¾ÑÑÐ¸ Ð·Ð°Ð²Ð¸ÑÐ¸Ñ Ð¾Ñ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ ÑÐ¸ÑÑÐµÐ¼Ñ)
            import random

            success_probability = 0.8  # 80% Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÑ ÑÑÐ¿ÐµÑÐ°
            return random.random() < success_probability

        except Exception as e:
            self.logger.error(f"Error Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°: {e}")
            return False

    async def _rollback_emergency_entry(self, reason: str):
        """ÐÑÐºÐ°ÑÐ¸ÑÑ Ð²ÑÐ¾Ð´ Ð² emergency ÑÐµÐ¶Ð¸Ð¼"""

        self.logger.error(f"ÐÑÐºÐ°Ñ Ð²ÑÐ¾Ð´Ð° Ð² emergency ÑÐµÐ¶Ð¸Ð¼: {reason}")

        with self._lock:
            # Ð¡Ð±ÑÐ¾Ñ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ
            self.state.current_phase = EmergencyPhase.NORMAL
            self.state.emergency_start_time = None
            self.state.active_triggers.clear()
            self.state.active_protocols.clear()
            self.state.last_phase_change = time.time()

        # ÐÑÐ±Ð»Ð¸ÐºÐ°ÑÐ¸Ñ ÑÐ¾Ð±ÑÑÐ¸Ñ Ð¾ÑÐºÐ°ÑÐ°
        await self._publish_emergency_status("EMERGENCY_ROLLBACK", reason, "ENTRY_FAILED")

    async def exit_emergency_mode(self, reason: str) -> bool:
        """
        ÐÑÐ¹ÑÐ¸ Ð¸Ð· Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°

        Args:
            reason: Reason Ð²ÑÑÐ¾Ð´Ð° Ð¸Ð· Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°

        Returns:
            bool: True ÐµÑÐ»Ð¸ Ð²ÑÑÐ¾Ð´ ÑÑÐ¿ÐµÑÐµÐ½
        """

        with self._lock:
            try:
                # Check, ÑÑÐ¾ Ð½Ð°ÑÐ¾Ð´Ð¸Ð¼ÑÑ Ð² Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð¼ ÑÐµÐ¶Ð¸Ð¼Ðµ
                if not self.state.is_in_emergency():
                    self.logger.warning("ÐÐ¾Ð¿ÑÑÐºÐ° Ð²ÑÑÐ¾Ð´Ð° Ð¸Ð· Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°, Ð½Ð¾ ÑÐµÐ¶Ð¸Ð¼ Ð½Ðµ Ð°ÐºÑÐ¸Ð²ÐµÐ½")
                    return False

                # ÐÐµÑÐµÑÐ¾Ð´ Ð² ÑÐ°Ð·Ñ Ð²ÑÑÐ¾Ð´Ð°
                self.state.current_phase = EmergencyPhase.EXITING
                self.state.last_phase_change = time.time()

                emergency_duration = self.state.get_emergency_duration()

                self.logger.info(
                    f"ð ÐÐ«Ð¥ÐÐ ÐÐ ÐÐÐÐ ÐÐÐÐÐÐ Ð ÐÐÐÐÐ ð\n"
                    f"Reason: {reason}\n"
                    f"Duration: {emergency_duration:.1f}Ñ"
                )

                # ÐÑÐ±Ð»Ð¸ÐºÐ°ÑÐ¸Ñ ÑÐ¾Ð±ÑÑÐ¸Ñ Ð²ÑÑÐ¾Ð´Ð°
                await self._publish_emergency_status(
                    "EMERGENCY_EXITING", reason, "RECOVERY_INITIATED"
                )

                # ÐÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
                success = await self._deactivate_emergency_protocols()

                if success:
                    # ÐÐµÑÐµÑÐ¾Ð´ Ðº ÑÑÐ°Ð±Ð¸Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸
                    await self._transition_to_stabilization()

                    # Update ÑÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐ¸
                    self.state.successful_recoveries += 1
                    self._update_recovery_time_stats(emergency_duration)

                    return True
                else:
                    # ÐÐ¾Ð·Ð²ÑÐ°Ñ Ðº Ð°ÐºÑÐ¸Ð²Ð½Ð¾Ð¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð¼Ñ ÑÐµÐ¶Ð¸Ð¼Ñ Ð¿ÑÐ¸ Ð½ÐµÑÐ´Ð°ÑÐµ Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸
                    self.state.current_phase = EmergencyPhase.ACTIVE
                    self.state.last_phase_change = time.time()

                    self.logger.error(
                        "Error Ð²ÑÑÐ¾Ð´Ð° Ð¸Ð· Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°, Ð²Ð¾Ð·Ð²ÑÐ°Ñ Ðº Ð°ÐºÑÐ¸Ð²Ð½Ð¾Ð¼Ñ ÑÐµÐ¶Ð¸Ð¼Ñ"
                    )
                    return False

            except Exception as e:
                self.logger.error(f"Error Ð²ÑÑÐ¾Ð´Ð° Ð¸Ð· Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°: {e}")
                return False

    async def _deactivate_emergency_protocols(self) -> bool:
        """ÐÐµÐ°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÐµ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ñ"""

        try:
            successful_deactivations = 0
            total_protocols = len(self.state.active_protocols)

            # ÐÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ñ Ð² Ð¾Ð±ÑÐ°ÑÐ½Ð¾Ð¼ Ð¿Ð¾ÑÑÐ´ÐºÐµ Ð¿ÑÐ¸Ð¾ÑÐ¸ÑÐµÑÐ°
            protocols_to_deactivate = sorted(
                self.state.active_protocols.keys(),
                key=lambda p: self.emergency_protocols[p].priority,
            )

            for protocol in protocols_to_deactivate:
                execution = self.state.active_protocols[protocol]
                action = execution.action

                self.logger.info(f"ÐÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð° {protocol.value}...")

                # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸
                success = await self._deactivate_protocol_action(action)

                if success:
                    successful_deactivations += 1
                    self.logger.info(f"Protocol {protocol.value} Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°Ð½ successfully")
                else:
                    self.logger.error(f"Error Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð° {protocol.value}")

                # ÐÑÐ±Ð»Ð¸ÐºÐ°ÑÐ¸Ñ ÑÐµÐ»ÐµÐ¼ÐµÑÑÐ¸Ð¸
                await self._publish_protocol_telemetry(protocol, execution, deactivating=True)

            # ÐÑÐ¸ÑÑÐºÐ° Ð°ÐºÑÐ¸Ð²Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
            self.state.active_protocols.clear()

            # Check Ð¾Ð±ÑÐµÐ³Ð¾ ÑÑÐ¿ÐµÑÐ°
            if total_protocols == 0:
                return True

            success_rate = successful_deactivations / total_protocols
            return success_rate >= 0.7  # Ð¢ÑÐµÐ±ÑÐµÑÑÑ 70% ÑÑÐ¿ÐµÑÐ½ÑÑ Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¹

        except Exception as e:
            self.logger.error(f"Error Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²: {e}")
            return False

    async def _deactivate_protocol_action(self, action: EmergencyAction) -> bool:
        """ÐÐµÐ°ÐºÑÐ¸Ð²Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ðµ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°"""

        try:
            # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸
            await asyncio.sleep(0.5)

            # Ð ÑÐµÐ°Ð»ÑÐ½Ð¾Ð¹ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð·Ð´ÐµÑÑ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð±ÑÑÑ Ð¾ÑÐºÐ°Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹,
            # Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð½ÑÑ Ð¿ÑÐ¸ Ð°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°

            component = action.target_component
            self.logger.debug(f"ÐÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð° Ð´Ð»Ñ {component}")

            # ÐÐ¼Ð¸ÑÐ°ÑÐ¸Ñ ÑÑÐ¿ÐµÑÐ° Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸
            import random

            return random.random() < 0.9  # 90% Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ÑÑÑ ÑÑÐ¿ÐµÑÐ½Ð¾Ð¹ Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸

        except Exception as e:
            self.logger.error(f"Error Ð´ÐµÐ°ÐºÑÐ¸Ð²Ð°ÑÐ¸Ð¸ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°: {e}")
            return False

    async def _transition_to_recovery_assessment(self):
        """ÐÐµÑÐµÑÐ¾Ð´ Ðº Ð¾ÑÐµÐ½ÐºÐµ Ð²Ð¾ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ"""

        with self._lock:
            self.state.current_phase = EmergencyPhase.RECOVERY_ASSESSMENT
            self.state.last_phase_change = time.time()

        self.logger.info("ÐÐµÑÐµÑÐ¾Ð´ Ðº Ð¾ÑÐµÐ½ÐºÐµ Ð³Ð¾ÑÐ¾Ð²Ð½Ð¾ÑÑÐ¸ Ð²Ð¾ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ")
        await self._publish_emergency_status("RECOVERY_ASSESSMENT", "Assessing system recovery", "")

    async def _transition_to_stabilization(self):
        """ÐÐµÑÐµÑÐ¾Ð´ Ðº ÑÑÐ°Ð±Ð¸Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸"""

        with self._lock:
            self.state.current_phase = EmergencyPhase.STABILIZATION
            self.state.last_phase_change = time.time()
            self.state.stabilization_progress = 0.0

        self.logger.info("ÐÐµÑÐµÑÐ¾Ð´ Ðº ÑÐ°Ð·Ðµ ÑÑÐ°Ð±Ð¸Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸")
        await self._publish_emergency_status("STABILIZATION", "System stabilization", "")

    async def _transition_to_normal(self):
        """ÐÐµÑÐµÑÐ¾Ð´ Ðº Ð½Ð¾ÑÐ¼Ð°Ð»ÑÐ½Ð¾Ð¼Ñ ÑÐµÐ¶Ð¸Ð¼Ñ"""

        with self._lock:
            emergency_duration = self.state.get_emergency_duration()

            # Ð¡Ð±ÑÐ¾Ñ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ
            self.state.current_phase = EmergencyPhase.NORMAL
            self.state.emergency_start_time = None
            self.state.active_triggers.clear()
            self.state.recovery_readiness = 0.0
            self.state.stabilization_progress = 0.0
            self.state.last_phase_change = time.time()

            # ÐÑÐ¸ÑÑÐºÐ° Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð½ÑÑ Ð¸ Ð½ÐµÑÐ´Ð°ÑÐ½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
            self.state.completed_protocols.clear()
            self.state.failed_protocols.clear()

        self.logger.info(
            f"â ÐÐÐ¡Ð¡Ð¢ÐÐÐÐÐÐÐÐÐ ÐÐÐÐÐ Ð¨ÐÐÐ â\n"
            f"ÐÐ¾Ð»Ð½Ð°Ñ duration Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°: {emergency_duration:.1f}Ñ\n"
            f"System Ð²Ð¾Ð·Ð²ÑÐ°ÑÐµÐ½Ð° Ðº Ð½Ð¾ÑÐ¼Ð°Ð»ÑÐ½Ð¾Ð¹ ÑÐ°Ð±Ð¾ÑÐµ"
        )

        await self._publish_emergency_status(
            "NORMAL", "Recovery completed successfully", "SYSTEM_RESTORED"
        )

    def _update_recovery_time_stats(self, duration: float):
        """Update ÑÑÐ°ÑÐ¸ÑÑÐ¸ÐºÑ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð²Ð¾ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ"""

        # Ð­ÐºÑÐ¿Ð¾Ð½ÐµÐ½ÑÐ¸Ð°Ð»ÑÐ½Ð¾ Ð²Ð·Ð²ÐµÑÐµÐ½Ð½Ð¾Ðµ ÑÑÐµÐ´Ð½ÐµÐµ
        if self.state.avg_recovery_time == 0.0:
            self.state.avg_recovery_time = duration
        else:
            alpha = 0.2  # Ð¤Ð°ÐºÑÐ¾Ñ ÑÐ³Ð»Ð°Ð¶Ð¸Ð²Ð°Ð½Ð¸Ñ
            self.state.avg_recovery_time = (
                alpha * duration + (1 - alpha) * self.state.avg_recovery_time
            )

    async def _publish_emergency_status(self, status: str, reason: str, context: str):
        """ÐÐ¿ÑÐ±Ð»Ð¸ÐºÐ¾Ð²Ð°ÑÑ ÑÑÐ°ÑÑÑ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°"""

        try:
            payload = EmergencyPayload(
                source_module="emergency_protocols",
                emergency_type=status,
                severity_level=3 if status in ["EMERGENCY_ENTERING", "EMERGENCY_ACTIVE"] else 1,
                trigger_reason=reason,
                affected_modules=["system"],
                required_actions=[context] if context else [],
            )

            priority = EventPriority.EMERGENCY if "EMERGENCY" in status else EventPriority.HIGH

            self.bus.publish(TopicType.ORCHESTRATION_EMERGENCY, payload, priority)

        except Exception as e:
            self.logger.error(f"Error Ð¿ÑÐ±Ð»Ð¸ÐºÐ°ÑÐ¸Ð¸ ÑÑÐ°ÑÑÑÐ° Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°: {e}")

    async def _publish_protocol_telemetry(
        self, protocol: ComponentProtocol, execution: ProtocolExecution, deactivating: bool = False
    ):
        """ÐÐ¿ÑÐ±Ð»Ð¸ÐºÐ¾Ð²Ð°ÑÑ ÑÐµÐ»ÐµÐ¼ÐµÑÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°"""

        try:
            action_type = "deactivation" if deactivating else "activation"

            payload = TelemetryPayload(
                source_module="emergency_protocols",
                metric_name=f"protocol_{action_type}",
                metric_value=1 if execution.is_successful() else 0,
                module_state={
                    "protocol": protocol.value,
                    "target_component": execution.action.target_component,
                    "duration": execution.get_duration(),
                    "success": execution.is_successful(),
                    "error": execution.error_message,
                },
                performance_data={
                    "execution_time": execution.get_duration(),
                    "estimated_time": execution.action.estimated_duration,
                    "efficiency": execution.action.estimated_duration
                    / max(execution.get_duration(), 0.1),
                },
            )

            self.bus.publish(TopicType.TELEMETRY_EVENT, payload, EventPriority.NORMAL)

        except Exception as e:
            self.logger.error(f"Error Ð¿ÑÐ±Ð»Ð¸ÐºÐ°ÑÐ¸Ð¸ ÑÐµÐ»ÐµÐ¼ÐµÑÑÐ¸Ð¸ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð°: {e}")

    async def force_emergency_exit(self, reason: str) -> bool:
        """
        ÐÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ Ð²ÑÑÐ¾Ð´ Ð¸Ð· Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°

        Args:
            reason: Reason Ð¿ÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½Ð¾Ð³Ð¾ Ð²ÑÑÐ¾Ð´Ð°

        Returns:
            bool: True ÐµÑÐ»Ð¸ Ð²ÑÑÐ¾Ð´ ÑÑÐ¿ÐµÑÐµÐ½
        """

        self.logger.critical(f"ð´ ÐÐ ÐÐÐ£ÐÐÐ¢ÐÐÐ¬ÐÐ«Ð ÐÐ«Ð¥ÐÐ ÐÐ ÐÐÐÐ ÐÐÐÐÐÐ Ð ÐÐÐÐÐ: {reason}")

        with self._lock:
            # ÐÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ ÑÐ±ÑÐ¾Ñ Ð²ÑÐµÑ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¹
            emergency_duration = self.state.get_emergency_duration()

            self.state.current_phase = EmergencyPhase.NORMAL
            self.state.emergency_start_time = None
            self.state.active_triggers.clear()
            self.state.active_protocols.clear()
            self.state.completed_protocols.clear()
            self.state.failed_protocols.clear()
            self.state.recovery_readiness = 0.0
            self.state.stabilization_progress = 0.0
            self.state.last_phase_change = time.time()

            # Update ÑÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐ¸ ÐºÐ°Ðº Ð½ÐµÑÐ´Ð°ÑÐ½Ð¾Ðµ recovery
            self.state.failed_recoveries += 1

        await self._publish_emergency_status("FORCE_EXIT", reason, "FORCED_RECOVERY")

        self.logger.warning(
            f"ÐÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ Ð²ÑÑÐ¾Ð´ completed. "
            f"Duration Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°: {emergency_duration:.1f}Ñ"
        )

        return True

    def manual_trigger_emergency(
        self, reason: str, additional_context: Optional[Dict[str, Any]] = None
    ) -> bool:
        """
        Ð ÑÑÐ½Ð¾Ð¹ start Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°

        Args:
            reason: Reason ÑÑÑÐ½Ð¾Ð³Ð¾ Ð·Ð°Ð¿ÑÑÐºÐ°
            additional_context: ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ ÐºÐ¾Ð½ÑÐµÐºÑÑ

        Returns:
            bool: True ÐµÑÐ»Ð¸ start ÑÑÐ¿ÐµÑÐµÐ½
        """

        self.logger.warning(f"Ð ÑÑÐ½Ð¾Ð¹ start Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°: {reason}")

        # ÐÑÐ¸Ð½ÑÑÐ¾Ð½Ð½ÑÐ¹ start
        asyncio.create_task(
            self.enter_emergency_mode(EmergencyTrigger.MANUAL_TRIGGER, reason, additional_context)
        )

        return True

    def get_current_status(self) -> Dict[str, Any]:
        """ÐÐ¾Ð»ÑÑÐ¸ÑÑ ÑÐµÐºÑÑÐ¸Ð¹ ÑÑÐ°ÑÑÑ ÑÐ¸ÑÑÐµÐ¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²"""

        with self._lock:
            status = {
                "current_phase": self.state.current_phase.value,
                "is_in_emergency": self.state.is_in_emergency(),
                "emergency_duration": self.state.get_emergency_duration(),
                "phase_duration": self.state.get_phase_duration(),
                "active_triggers": [t.value for t in self.state.active_triggers],
                "active_protocols": len(self.state.active_protocols),
                "completed_protocols": len(self.state.completed_protocols),
                "failed_protocols": len(self.state.failed_protocols),
                "recovery_readiness": self.state.recovery_readiness,
                "stabilization_progress": self.state.stabilization_progress,
                "statistics": {
                    "total_emergencies": self.state.total_emergencies,
                    "successful_recoveries": self.state.successful_recoveries,
                    "failed_recoveries": self.state.failed_recoveries,
                    "avg_recovery_time": self.state.avg_recovery_time,
                    "success_rate": (
                        self.state.successful_recoveries
                        / max(1, self.state.successful_recoveries + self.state.failed_recoveries)
                    ),
                },
            }

            # ÐÐµÑÐ°Ð»Ð¸ Ð°ÐºÑÐ¸Ð²Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
            if self.state.active_protocols:
                status["active_protocol_details"] = {
                    protocol.value: {
                        "target": execution.action.target_component,
                        "duration": execution.get_duration(),
                        "completed": execution.is_completed(),
                        "success": execution.is_successful(),
                    }
                    for protocol, execution in self.state.active_protocols.items()
                }

            return status

    def get_protocol_history(self, limit: int = 20) -> List[Dict[str, Any]]:
        """ÐÐ¾Ð»ÑÑÐ¸ÑÑ Ð¸ÑÑÐ¾ÑÐ¸Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²"""

        with self._lock:
            all_executions = (
                self.state.completed_protocols
                + self.state.failed_protocols
                + list(self.state.active_protocols.values())
            )

            # Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¿Ð¾ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð½Ð°ÑÐ°Ð»Ð°
            sorted_executions = sorted(all_executions, key=lambda x: x.started_at, reverse=True)

            return [
                {
                    "protocol": exec.action.protocol.value,
                    "target_component": exec.action.target_component,
                    "action_type": exec.action.action_type,
                    "started_at": exec.started_at,
                    "duration": exec.get_duration(),
                    "completed": exec.is_completed(),
                    "success": exec.is_successful(),
                    "error": exec.error_message,
                }
                for exec in sorted_executions[:limit]
            ]

    def __repr__(self) -> str:
        """Ð¡ÑÑÐ¾ÐºÐ¾Ð²Ð¾Ðµ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÐ¸ÑÑÐµÐ¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²"""
        return (
            f"EmergencyProtocols(phase={self.state.current_phase.value}, "
            f"active_protocols={len(self.state.active_protocols)}, "
            f"emergencies={self.state.total_emergencies})"
        )


# Ð£Ð´Ð¾Ð±Ð½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ ÑÐ¸ÑÑÐµÐ¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
def create_default_emergency_protocols(**kwargs) -> EmergencyProtocols:
    """Create ÑÐ¸ÑÑÐµÐ¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð² Ñ Ð½Ð°ÑÑÑÐ¾Ð¹ÐºÐ°Ð¼Ð¸ Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ"""
    return EmergencyProtocols(**kwargs)


def create_strict_emergency_protocols() -> EmergencyProtocols:
    """Create ÑÑÑÐ¾Ð³ÑÑ ÑÐ¸ÑÑÐµÐ¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð² Ñ Ð±ÑÑÑÑÑÐ¼ ÑÐµÐ°Ð³Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸ÐµÐ¼"""
    return EmergencyProtocols(
        enable_auto_detection=True,
        enable_auto_recovery=True,
        max_emergency_duration=300.0,  # 5 Ð¼Ð¸Ð½ÑÑ Ð¼Ð°ÐºÑÐ¸Ð¼ÑÐ¼
        stabilization_timeout=60.0,  # 1 minute ÑÑÐ°Ð±Ð¸Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸
        recovery_assessment_interval=15.0,  # ÐÑÐµÐ½ÐºÐ° ÐºÐ°Ð¶Ð´ÑÐµ 15 ÑÐµÐºÑÐ½Ð´
    )


def create_permissive_emergency_protocols() -> EmergencyProtocols:
    """Create Ð¼ÑÐ³ÐºÑÑ ÑÐ¸ÑÑÐµÐ¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð² Ñ Ð´Ð»Ð¸ÑÐµÐ»ÑÐ½ÑÐ¼Ð¸ Ð¸Ð½ÑÐµÑÐ²Ð°Ð»Ð°Ð¼Ð¸"""
    return EmergencyProtocols(
        enable_auto_detection=True,
        enable_auto_recovery=True,
        max_emergency_duration=1200.0,  # 20 Ð¼Ð¸Ð½ÑÑ Ð¼Ð°ÐºÑÐ¸Ð¼ÑÐ¼
        stabilization_timeout=300.0,  # 5 Ð¼Ð¸Ð½ÑÑ ÑÑÐ°Ð±Ð¸Ð»Ð¸Ð·Ð°ÑÐ¸Ð¸
        recovery_assessment_interval=60.0,  # ÐÑÐµÐ½ÐºÐ° ÐºÐ°Ð¶Ð´ÑÑ Ð¼Ð¸Ð½ÑÑÑ
    )


if __name__ == "__main__":
    # ÐÑÐ¸Ð¼ÐµÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ
    import asyncio
    from ..orchestrator.resonance_bus import initialize_global_bus

    async def demo_emergency_protocols():
        # Initialization ÑÐ¸Ð½Ñ
        await initialize_global_bus()

        # Creation ÑÐ¸ÑÑÐµÐ¼Ñ Ð°Ð²Ð°ÑÐ¸Ð¹Ð½ÑÑ Ð¿ÑÐ¾ÑÐ¾ÐºÐ¾Ð»Ð¾Ð²
        emergency_system = create_default_emergency_protocols()

        # Start Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ¸Ð½Ð³Ð°
        await emergency_system.start_monitoring()

        # Testing ÑÑÑÐ½Ð¾Ð³Ð¾ Ð·Ð°Ð¿ÑÑÐºÐ° Ð°Ð²Ð°ÑÐ¸Ð¹Ð½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð°
        success = emergency_system.manual_trigger_emergency("Test emergency", {"test_mode": True})

        if success:
            print("Emergency ÑÐµÐ¶Ð¸Ð¼ started")

            # ÐÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸
            for i in range(10):
                status = emergency_system.get_current_status()
                print(
                    f"Ð¡ÑÐ°ÑÑÑ: {status['current_phase']} "
                    f"(duration: {status['emergency_duration']:.1f}Ñ)"
                )
                await asyncio.sleep(2.0)

            # ÐÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½ÑÐ¹ Ð²ÑÑÐ¾Ð´ Ð´Ð»Ñ ÑÐµÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ
            await emergency_system.force_emergency_exit("Test completed")

        # Ð¤Ð¸Ð½Ð°Ð»ÑÐ½ÑÐ¹ ÑÑÐ°ÑÑÑ
        final_status = emergency_system.get_current_status()
        print(f"\nÐ¤Ð¸Ð½Ð°Ð»ÑÐ½ÑÐ¹ ÑÑÐ°ÑÑÑ: {final_status['current_phase']}")
        print(f"Ð¡ÑÐ°ÑÐ¸ÑÑÐ¸ÐºÐ°: {final_status['statistics']}")

        # Stop Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ¸Ð½Ð³Ð°
        await emergency_system.stop_monitoring()

    # Start Ð´ÐµÐ¼Ð¾
    if __name__ == "__main__":
        asyncio.run(demo_emergency_protocols())
